<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>clippy &middot; stuart crust</title>

    <meta name="description" content="a constant work in progress">

    <meta name="generator" content="Hugo 0.79.0" />
    <meta name="twitter:card" content="summary">
    
    <meta name="twitter:title" content="clippy &middot; stuart crust">
    <meta name="twitter:description" content="a constant work in progress">

    <meta property="og:type" content="article">
    <meta property="og:title" content="clippy &middot; stuart crust">
    <meta property="og:description" content="a constant work in progress">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">

    <link rel="stylesheet" href='/css/blog.min.css'>
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="stuart crust" href='https://stuartcrust.com/index.xml' />
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="https://stuartcrust.com/">stuart crust</a></h1>
            <h2 class="brand-tagline"> a constant work in progress </h2>
        </hgroup>

        <nav class="nav">
            <ul class="nav-list">
                
                <li class="nav-item">
                    <a class="pure-button" href="https://twitter.com/0xazure">
                        <i class="fa fa-twitter"></i>
                    </a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/0xazure">
                        <i class="fa fa-github-alt"></i>
                    </a>
                </li>
                
                
                
                <li class="nav-item">
                    <a class="pure-button" href='https://stuartcrust.com/index.xml'>
                        <i class="fa fa-rss"></i>
                    </a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">03 Jan 2019</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://stuartcrust.com/2019/01/lints-syntax-parsing-and-you/" class="post-title">Lints, Syntax Parsing, and You</a>

                        <p class="post-meta">
                            
                            
    under 
    <a class="post-category post-category-open-source" href='/categories/open-source'>open source</a><a class="post-category post-category-rust" href='/categories/rust'>rust</a><a class="post-category post-category-clippy" href='/categories/clippy'>clippy</a>


                        </p>
                    </header>

                    <div class="post-description">
                        <p>In my <a href="/2018/12/yak-shaving-in-f/">previous post</a> I ran into a number of issues and confusion around <code>clippy</code>&rsquo;s <code>#[clippy::author]</code> annotation and autogenerated code.
Instead of continuing with <code>clippy</code>&rsquo;s documentation, I&rsquo;m going to jump over to <a href="https://llogiq.github.io/">llogiq</a>&rsquo;s blogpost on <a href="https://llogiq.github.io/2015/06/04/workflows.html">writing <code>clippy</code> lints</a> and see what I can learn about lint implementation and the necessary datatypes.</p>
<p>Because <code>clippy</code> is a Rust toolchain component, and the <a href="https://crates.io/crates/clippy"><code>clippy</code> version on https://crates.io</a> is no longer maintained, documentation tools like <a href="https://docs.rs">docs.rs</a> are unavailable for browsing <code>clippy</code>&rsquo;s types.
Fortunately, Rust has a very strong offline documentation story, and generating documentation for a project is as simple as <code>cargo doc --open</code>.
This can be a little tricky to get set up when you&rsquo;re halfway through implementing a feature and looking for information in the documentation though, because the project has to successfully compile as part of generating the offline documentation.</p>
<p>Since <code>clippy</code> uses Rust compiler types to implement lints, we also need to have access to the documentation for <code>rustc</code>, Rust&rsquo;s compiler, on the <code>nightly</code> toolchain; this can be accessed at <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/index.html">https://doc.rust-lang.org/nightly/nightly-rustc/rustc/index.html</a>.
Unfortunately this set of compiler documentation is not available offline which seems like a gap in Rust&rsquo;s documentation story.</p>
<h2 id="steps-to-writing-a-clippy-lint">Steps to Writing a Clippy Lint</h2>
<p>I&rsquo;ve broken the process I went through to implement this lint into steps to more clearly separate the different parts of a lint, the tools and processes involved at each stage, and problems and errors I encountered along the way as well as solutions I found where applicable.</p>
<p>For quick reference, here is a list of the steps involved:</p>
<ul>
<li><a href="#step-one-write-an-example">Step One: Write an Example</a></li>
<li><a href="#step-two-declare-the-lint">Step Two: Declare the Lint</a></li>
<li><a href="#step-three-register-the-lint-with-clippy">Step Three: Register the Lint with Clippy</a></li>
<li><a href="#step-four-start-implementing-lint-passes">Step Four: Start Implementing Lint Passes</a></li>
<li><a href="#step-five-inspect-and-interpret-the-ast">Step Five: Inspect and Interpret the AST</a></li>
<li><a href="#step-six-implement-earlylintpass">Step Six: Implement EarlyLintPass</a></li>
<li><a href="#step-seven-generate-the-stderr-file-for-the-new-lint">Step Seven: Generate the .stderr File for the New Lint</a></li>
<li><a href="#step-eight-iterate">Step Eight: Iterate</a></li>
<li><a href="#step-nine-run-the-full-test-suite">Step Nine: Run the Full Test Suite</a></li>
<li><a href="#step-ten-linting-clippy-with-local-changes">Step Ten: Linting Clippy with Local Changes</a></li>
</ul>
<h3 id="step-one-write-an-example">Step One: Write an Example</h3>
<p>The first step in writing a lint, as with most code, is to write the piece that <em>uses</em> the code you&rsquo;re going to write.
If we were writing regular code this might take the form of one or more test cases, but because we&rsquo;re writing a lint we want to instead write an example of the code we&rsquo;re trying to lint against.
I&rsquo;ve already done this earlier when I tried to use the <code>#[clippy::author]</code> directive, so I&rsquo;m going to reuse the same example while using llogiq&rsquo;s blogpost as a guide for my own lint.</p>
<p>Here&rsquo;s the small code example we want to lint against:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyStruct</span> {
    id: <span style="color:#66d9ef">usize</span>
}

<span style="color:#66d9ef">impl</span> MyStruct {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_id</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">usize</span> {
        self.id
    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
   <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> MyStruct { id: <span style="color:#ae81ff">42</span> };
   s.get_id();
}
</code></pre></div><h3 id="step-two-declare-the-lint">Step Two: Declare the Lint</h3>
<p>After writing the example to lint against, we need to actually define the lint; this is done using the <code>declare_clippy_lint!</code> macro from the <code>clippy_lints</code> crate.
I tried compiling <code>clippy</code> after declaring the lint and ran into the following error:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">cargo check
   Compiling clippy_lints v0.0.212
error: cannot find macro `declare_tool_lint!` in this scope
  --&gt; clippy_lints/src/lib.rs:53:9
   |
53 |           declare_tool_lint! { pub clippy::$name, Warn, $description, report_in_external_macro: true }
   |           ^^^^^^^^^^^^^^^^^
   |
  ::: clippy_lints/src/getter_prefix.rs:3:1
   |
3  | / declare_clippy_lint! {
4  | |     pub GETTER_PREFIX,
5  | |     style,
6  | |     &#34;prefixing a getter with `get_`, which does not follow convention&#34;
7  | | }
   | |_- in this macro invocation

error: aborting due to previous error

error: Could not compile `clippy_lints`.
warning: build failed, waiting for other jobs to finish...
error: cannot find macro `declare_tool_lint!` in this scope
  --&gt; clippy_lints/src/lib.rs:53:9
   |
53 |           declare_tool_lint! { pub clippy::$name, Warn, $description, report_in_external_macro: true }
   |           ^^^^^^^^^^^^^^^^^
   |
  ::: clippy_lints/src/getter_prefix.rs:3:1
   |
3  | / declare_clippy_lint! {
4  | |     pub GETTER_PREFIX,
5  | |     style,
6  | |     &#34;prefixing a getter with `get_`, which does not follow convention&#34;
7  | | }
   | |_- in this macro invocation

error: aborting due to previous error

error: Could not compile `clippy_lints`.

To learn more, run the command again with --verbose.
</code></pre></div><p><code>cargo</code> can&rsquo;t find the <code>declare_tool_lint!</code> macro in the current scope, which is not an error I was expecting to see because I didn&rsquo;t think I was using that macro in my lint definition.
It turns out that the definition of the <code>declare_clippy_lint!</code> macro uses the <code>declare_tool_lint!</code> macro, so this second macro must be brought into scope before the first can be used.
I&rsquo;m not very familiar with macros or metaprogramming in Rust, but after looking at a number of other lints it seems like all of them <code>use</code> the <code>declare_tool_lint!</code> macro so I will too.</p>
<p>Here is the lint code so far, including the first line which imports the dependent lint:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::rustc::declare_tool_lint;

declare_clippy_lint<span style="color:#f92672">!</span> {
    <span style="color:#66d9ef">pub</span> GETTER_PREFIX,
    style,
    <span style="color:#e6db74">&#34;prefixing a getter with `get_`, which does not follow convention&#34;</span>
}
</code></pre></div><p>As part of declaring the lint, we also want to document the lint by describing what it does and include some examples of code that will not pass the lint and alternatives that <em>will</em> pass the lint rules.
By following a standard convention, documentation written for each lint can be extracted and added to the <a href="https://rust-lang.github.io/rust-clippy/master/">lint list</a> which provides a filterable list of all of <code>clippy</code>&rsquo;s lints.</p>
<p>Rust provides a lot of tools for documenting Rust code, the cornerstone of which is <a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments">documentation comments</a>. Documentation comments support Markdown syntax for formatting and are used to generate browsable HTML pages, without requiring the author to maintain separate written documentation. Documentation comments also drive other tools such as <a href="https://docs.rs/">docs.rs</a>.</p>
<p>Here is a (very rough) initial documentation comment for the lint, including examples of bad and good code samples:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#e6db74">/// **What it does:** Checks for the `get_` prefix on getters.
</span><span style="color:#e6db74">///
</span><span style="color:#e6db74">/// **Why is this bad?** The Rust API Guidelines section on naming
</span><span style="color:#e6db74">/// [specifies](https://rust-lang-nursery.github.io/api-guidelines/naming.html#getter-names-follow-rust-convention-c-getter)
</span><span style="color:#e6db74">/// that the `get_` prefix is not used for getters in Rust code unless
</span><span style="color:#e6db74">/// there is a single and obvious thing that could reasonably be gotten by
</span><span style="color:#e6db74">/// a getter.
</span><span style="color:#e6db74">///
</span><span style="color:#e6db74">/// **Known problems:** Exceptions not yet implemented.
</span><span style="color:#e6db74">///
</span><span style="color:#e6db74">/// **Example:**
</span><span style="color:#e6db74">///
</span><span style="color:#e6db74">/// ```rust
</span><span style="color:#e6db74">/// // Bad
</span><span style="color:#e6db74">/// impl B {
</span><span style="color:#e6db74">///     fn get_id(&amp;self) -&gt; usize {
</span><span style="color:#e6db74">///         ..
</span><span style="color:#e6db74">///     }
</span><span style="color:#e6db74">///}
</span><span style="color:#e6db74">///
</span><span style="color:#e6db74">/// // Good
</span><span style="color:#e6db74">/// impl G {
</span><span style="color:#e6db74">///     fn id(&amp;self) -&gt; usize {
</span><span style="color:#e6db74">///         ..
</span><span style="color:#e6db74">///     }
</span><span style="color:#e6db74">/// }
</span><span style="color:#e6db74">/// ```
</span></code></pre></div><h3 id="step-three-register-the-lint-with-clippy">Step Three: Register the Lint with Clippy</h3>
<p>This is a largely automated process thanks to some <code>clippy</code> tooling as described in the <a href="https://github.com/rust-lang/rust-clippy/blob/master/CONTRIBUTING.md#how-clippy-works">How Clippy Works</a> section of the contribution documentation.
Simply (re-)run <code>util/dev update_lints</code> as necessary, which autogenerates the majority of <code>clippy_lints/src/lib.rs</code> to declare lints and lint groups.</p>
<p>Alternatively, this can be done manually by adding the lint to the correct lint group inside the <code>register_plugins</code> function.</p>
<p>Regardless of how the lint is added to the lint groups, the lint must be registered with the lint registry by introducing the lint as either an early or late lint pass.
In the case of this lint, which will be implemented as an early lint pass, the following line adds it to the lint registry as declared inside the <code>register_plugins</code> function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">reg.register_early_lint_pass(<span style="color:#66d9ef">box</span> naming::GetterPrefix);
</code></pre></div><h3 id="step-four-start-implementing-lint-passes">Step Four: Start Implementing Lint Passes</h3>
<p>Now that the lint is defined and registered with <code>clippy</code>, we can start implementing the logic to lint against the example we implemented in <a href="#step-one-write-an-example">Step One</a>.</p>
<p>For most lints there are two traits that need to be implemented so the lint can be registered with <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_plugin/registry/struct.Registry.html"><code>rustc_plugin::registry::Registry</code></a>: the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/trait.LintPass.html"><code>LintPass</code></a> trait and one of either the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/trait.EarlyLintPass.html"><code>EarlyLintPass</code></a> or the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/trait.LateLintPass.html"><code>LateLintPass</code></a> trait.
<code>LintPass</code> is apparently necessary to <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/trait.LintPass.html#tymethod.get_lints">provide descriptions of the possible lints the lint can emit</a>, but in all of the lints I have looked at, the <code>LintPass</code> implementation always takes the form:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span> LintPass <span style="color:#66d9ef">for</span> Pass {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_lints</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">LintArray</span> {
        lint_array<span style="color:#f92672">!</span>(LINT_NAME)
    }
}
</code></pre></div><p>so I&rsquo;m surprised there hasn&rsquo;t been a <code>#[derive]</code> annotation written for it or some kind of macro that would reduce the repetition.</p>
<p>As for <code>EarlyLintPass</code> or <code>LateLintPass</code>, the choice of which trait to implement comes down to the kind of information a given lint needs about the code it is linting: <code>EarlyLintPass</code> methods only provide <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree (AST)</a> information, whereas <code>LateLintPass</code> methods are, as the name implies, executed later in the compilation process and contain type information.
Since this lint is only interested in function names and checking them against known patterns, I&rsquo;ve decided to implement the <code>EarlyLintPass</code> trait.
There seems to be a lot of overlap in method signatures between the two types of lint pass, so if I need to switch to <code>LateLintPass</code> to get access to additional type information it should not be too difficult to transition over.</p>
<h3 id="step-five-inspect-and-interpret-the-ast">Step Five: Inspect and Interpret the AST</h3>
<p>Most everything up until now has been boilerplate for getting the lint set up and correctly registered with <code>clippy</code>&rsquo;s infrastructure.
Now that we have everything set up, we need to figure out how to tell the lint to match against the undesired function names we&rsquo;ve already written in our test.
To do this, we need to first understand how the <code>rustc</code> compiler sees the code we have written, which for <code>rustc</code> is represented as an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree (AST)</a>, and then parse that tree to match against undesired nodes within the tree that correspond to the Rust source code.
To retrieve this representation, we can use <code>rustc</code> to generate the AST and then inspect it manually to get a sense of the program structure; <code>rustc</code> has the <code>-Z</code> option for controlling various debug options (see <code>rustc --help</code>), and one of these options tells <code>rustc</code> to print the AST as JSON and halt compilation: <code>-Z ast-json</code>.</p>
<p>The full command to print the AST as JSON, specifying the individual test for this lint whose code we want to inspect, is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ rustc tests/ui/naming.rs -L target/debug -Z ast-json
</code></pre></div><p>The initial output of this command is utterly unreadable because <code>rustc</code> prints it as a single line of JSON, so I&rsquo;m going to use <a href="https://stedolan.github.io/jq/"><code>jq</code></a> to pretty-print the AST so it&rsquo;s easier to read:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
    <span style="color:#f92672">&#34;module&#34;</span>: {
        <span style="color:#f92672">&#34;inner&#34;</span>: {
            <span style="color:#f92672">&#34;lo&#34;</span>: <span style="color:#ae81ff">426</span>,
            <span style="color:#f92672">&#34;hi&#34;</span>: <span style="color:#ae81ff">611</span>
        },
        <span style="color:#f92672">&#34;items&#34;</span>: [
            [<span style="color:#960050;background-color:#1e0010">snip</span> <span style="color:#ae81ff">1604</span> <span style="color:#960050;background-color:#1e0010">lines</span>]
        ],
        <span style="color:#f92672">&#34;inline&#34;</span>: <span style="color:#66d9ef">true</span>
    },
    <span style="color:#f92672">&#34;attrs&#34;</span>: [],
    <span style="color:#f92672">&#34;span&#34;</span>: {
        <span style="color:#f92672">&#34;lo&#34;</span>: <span style="color:#ae81ff">426</span>,
        <span style="color:#f92672">&#34;hi&#34;</span>: <span style="color:#ae81ff">611</span>
    }
}
</code></pre></div><p>In all, the AST for my 12-line test file ended up expanding to a 1627-line (pretty-printed) JSON file.
The <code>items</code> key and its 1604 lines are where the actually interesting AST information is in the data structure, containing information about every identifier, implementation, attribute, etc in the code.
Within the <code>items</code> array, the name of the function in the test, <code>get_id</code>, appears 5 times in various contexts such as <code>&quot;variant&quot;: &quot;Impl&quot;</code> and <code>&quot;variant&quot;: &quot;MethodCall&quot;</code>.
The following is what I believe to be the beginning of the AST for the <code>get_id</code> function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
    <span style="color:#f92672">&#34;id&#34;</span>: <span style="color:#ae81ff">20</span>,
    <span style="color:#f92672">&#34;ident&#34;</span>: <span style="color:#e6db74">&#34;get_id&#34;</span>,
    <span style="color:#f92672">&#34;vis&#34;</span>: {
        <span style="color:#f92672">&#34;node&#34;</span>: <span style="color:#e6db74">&#34;Public&#34;</span>,
        <span style="color:#f92672">&#34;span&#34;</span>: {
        <span style="color:#f92672">&#34;lo&#34;</span>: <span style="color:#ae81ff">485</span>,
        <span style="color:#f92672">&#34;hi&#34;</span>: <span style="color:#ae81ff">488</span>
        }
    },
    <span style="color:#f92672">&#34;defaultness&#34;</span>: <span style="color:#e6db74">&#34;Final&#34;</span>,
    <span style="color:#f92672">&#34;attrs&#34;</span>: [],
    <span style="color:#f92672">&#34;generics&#34;</span>: {
        <span style="color:#f92672">&#34;params&#34;</span>: [],
        <span style="color:#f92672">&#34;where_clause&#34;</span>: {
            <span style="color:#f92672">&#34;id&#34;</span>: <span style="color:#ae81ff">21</span>,
            <span style="color:#f92672">&#34;predicates&#34;</span>: [],
            <span style="color:#f92672">&#34;span&#34;</span>: {
                <span style="color:#f92672">&#34;lo&#34;</span>: <span style="color:#ae81ff">0</span>,
                <span style="color:#f92672">&#34;hi&#34;</span>: <span style="color:#ae81ff">0</span>
            }
        },
        <span style="color:#f92672">&#34;span&#34;</span>: {
            <span style="color:#f92672">&#34;lo&#34;</span>: <span style="color:#ae81ff">0</span>,
            <span style="color:#f92672">&#34;hi&#34;</span>: <span style="color:#ae81ff">0</span>
        }
    },
    <span style="color:#960050;background-color:#1e0010">...</span>
}
</code></pre></div><p>Specifically, the following are the nodes that describe the <code>pub fn get_id</code> text literals of the function signature:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#e6db74">&#34;tokens&#34;</span><span style="color:#960050;background-color:#1e0010">:</span> [
    {
        <span style="color:#f92672">&#34;variant&#34;</span>: <span style="color:#e6db74">&#34;Token&#34;</span>,
        <span style="color:#f92672">&#34;fields&#34;</span>: [
            {
                <span style="color:#f92672">&#34;lo&#34;</span>: <span style="color:#ae81ff">485</span>,
                <span style="color:#f92672">&#34;hi&#34;</span>: <span style="color:#ae81ff">488</span>
            },
            {
                <span style="color:#f92672">&#34;variant&#34;</span>: <span style="color:#e6db74">&#34;Ident&#34;</span>,
                <span style="color:#f92672">&#34;fields&#34;</span>: [
                    <span style="color:#e6db74">&#34;pub&#34;</span>,
                    <span style="color:#66d9ef">false</span>
                ]
            }
        ]
    },
    {
        <span style="color:#f92672">&#34;variant&#34;</span>: <span style="color:#e6db74">&#34;Token&#34;</span>,
        <span style="color:#f92672">&#34;fields&#34;</span>: [
            {
                <span style="color:#f92672">&#34;lo&#34;</span>: <span style="color:#ae81ff">489</span>,
                <span style="color:#f92672">&#34;hi&#34;</span>: <span style="color:#ae81ff">491</span>
            },
            {
                <span style="color:#f92672">&#34;variant&#34;</span>: <span style="color:#e6db74">&#34;Ident&#34;</span>,
                <span style="color:#f92672">&#34;fields&#34;</span>: [
                    <span style="color:#e6db74">&#34;fn&#34;</span>,
                    <span style="color:#66d9ef">false</span>
                ]
            }
        ]
    },
    {
        <span style="color:#f92672">&#34;variant&#34;</span>: <span style="color:#e6db74">&#34;Token&#34;</span>,
        <span style="color:#f92672">&#34;fields&#34;</span>: [
            {
                <span style="color:#f92672">&#34;lo&#34;</span>: <span style="color:#ae81ff">492</span>,
                <span style="color:#f92672">&#34;hi&#34;</span>: <span style="color:#ae81ff">498</span>
            },
            {
                <span style="color:#f92672">&#34;variant&#34;</span>: <span style="color:#e6db74">&#34;Ident&#34;</span>,
                <span style="color:#f92672">&#34;fields&#34;</span>: [
                    <span style="color:#e6db74">&#34;get_id&#34;</span>,
                    <span style="color:#66d9ef">false</span>
                ]
            }
        ]
    },
]
</code></pre></div><p>Now that the relevant sections of the AST have been identified, we can use this information to get a better understanding of how <code>rustc</code> (and thus tools like <code>clippy</code>) understand the written Rust code in the source file.
This information can be useful at many different stages of lint implementation, particularly if we need to debug out lint or we are not matching the expected nodes in our lint code.</p>
<h3 id="step-six-implement-earlylintpass">Step Six: Implement EarlyLintPass</h3>
<p>The <code>EarlyLintPass</code> trait requires the implementation of one of its provided methods to perform the lint work.
Looking at the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/trait.EarlyLintPass.html">list of provided methods</a>, however, I&rsquo;m not really sure where to start or which method to implement.
A lot of <code>rustc</code>&rsquo;s internals seem to be chronically under-documented, which makes it very difficult to understand how different internals are used (what&rsquo;s the difference between <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/trait.EarlyLintPass.html#method.check_item"><code>check_item</code></a> and <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/trait.EarlyLintPass.html#method.check_item_post"><code>check_item_post</code></a>, for example?) or the subtle (or not so subtle) differences between various types or methods.</p>
<p>My strategy in learning about the <code>rustc</code> internals so far has been a combination of looking at existing lints and trying to identify what the internals do based on the lint&rsquo;s goals and existing code, as well as inspecting not the <code>EarlyLintPass</code> methods themselves but rather the associated types such as <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.Item.html"><code>syntax::ast::Item</code></a> or <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.Local.html"><code>syntax::ast::Local</code></a> which are generally better documented than the methods that use them.
These associated types also match very closely if not exactly to the AST structure produced by <code>rustc</code>, so by identifying the structure of the information in the AST as above, it is easier to choose the correct function to implement based on its associated type which contains the same information as the already-identified AST subtree(s).</p>
<p>Based on my understanding, it looks like the method that I want to implement is <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/trait.EarlyLintPass.html#method.check_item"><code>check_item</code></a> which will yield <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.Item.html"><code>syntax::ast::Item</code></a> instances whose <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/enum.ItemKind.html"><code>syntax::ast::ItemKind</code></a> we can then match on for <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/enum.ItemKind.html#variant.Fn">function declarations</a>.</p>
<p>My initial implementation of the <code>EarlyLintPass</code> trait based on the above yielded the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span> EarlyLintPass <span style="color:#66d9ef">for</span> GetterPrefix {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">check_item</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">EarlyContext</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;_</span><span style="color:#f92672">&gt;</span>, item: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">ast</span>::Item) {
        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> ast::ItemKind::Fn(..) <span style="color:#f92672">=</span> item.node {
            <span style="color:#66d9ef">let</span> name <span style="color:#f92672">=</span> item.ident.name;
            <span style="color:#66d9ef">if</span> name.as_str().starts_with(<span style="color:#e6db74">&#34;get_&#34;</span>) {
                span_lint(cx, GETTER_PREFIX, item.span, <span style="color:#e6db74">&#34;prefixing a getter with `get_` does not follow naming conventions&#34;</span>);
            }
        }
    }
}
</code></pre></div><p>This implementation checks each <code>Item</code> in the AST and looks for nodes identified as <code>ItemKind::Fn</code>; that is, functions declared in the source.
For matching nodes, the name is extracted from the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/source_map/symbol/struct.Ident.html">node identifier</a> and is checked to see if it starts with the <code>get_</code> prefix.
The <a href="https://github.com/rust-lang/rust-clippy/blob/261ebcfbb4f4c70230af0ec18d3d592a9825ecf0/clippy_lints/src/utils/mod.rs#L600-L602"><code>span_lint</code></a> function comes from <a href="https://github.com/rust-lang/rust-clippy/tree/master/clippy_lints/src/utils"><code>clippy</code>&rsquo;s lint utils</a> and is what actually contextualizes lint warnings and errors around the offending code and outputs the lint message.</p>
<p>However, it turns out that <code>if let ast::ItemKind::Fn(..)</code> only matches the <code>main</code> function name of the test case, rather than my expectation that it would match all functions declared within the file.</p>
<p>Instead, since we are interested in functions implemented for a type, we can use the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/trait.EarlyLintPass.html#method.check_impl_item"><code>check_impl_item</code></a> method which will yield <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.ImplItem.html"><code>syntax::ast::ImplItem</code></a> instances whose <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/enum.ImplItemKind.html"><code>syntax::ast::ImplItemKind</code></a> we can then match on for <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/enum.ImplItemKind.html#variant.Method">methods</a> like so:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span> EarlyLintPass <span style="color:#66d9ef">for</span> GetterPrefix {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">check_impl_item</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">EarlyContext</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;_</span><span style="color:#f92672">&gt;</span>, implitem: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">ast</span>::ImplItem) {
        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> ast::ImplItemKind::Method(..) <span style="color:#f92672">=</span> implitem.node {
            <span style="color:#66d9ef">let</span> name <span style="color:#f92672">=</span> implitem.ident.name;
            <span style="color:#66d9ef">if</span> name.as_str().starts_with(<span style="color:#e6db74">&#34;get_&#34;</span>) {
                span_lint(
                    cx,
                    GETTER_PREFIX,
                    implitem.span,
                    <span style="color:#e6db74">&#34;prefixing a getter with `get_` does not follow naming conventions&#34;</span>
                );
            }
        }
    }
}
</code></pre></div><p>The above implementation works very similarly to the initial implementation, but instead of checking <code>Item</code>s looking for <code>ItemKind::Fn</code>, it instead looks at <code>ImplItem</code>s in the AST and matches <code>ImplItemKind::Method</code> nodes (since implementation nodes also include <code>const</code> declarations, types and type aliases, traits, and macros in addition to methods).</p>
<p>To test an individual lint without the full <code>clippy</code> test harness (or to see <code>println!</code>s or other debugging statements more clearly), we can use the following <code>clippy-driver</code> incantation and specify a single UI test file, <code>tests/ui/naming.rs</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ CLIPPY_TESTS<span style="color:#f92672">=</span>true cargo run --bin clippy-driver -- -L ./target/debug tests/ui/naming.rs
</code></pre></div><p>This lint pass implementation results in the following (successful) lint warning:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">warning: prefixing a getter with `get_` does not follow naming conventions
  --&gt; tests/ui/naming.rs:15:5
   |
15 | /     pub fn get_id(&amp;self) -&gt; usize {
16 | |         self.id
17 | |     }
   | |_____^
   |
   = note: #[warn(clippy::getter_prefix)] on by default
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#getter_prefix
</code></pre></div><h3 id="step-seven-generate-the-stderr-file-for-the-new-lint">Step Seven: Generate the .stderr File for the New Lint</h3>
<p>To test its behaviour, <code>clippy</code> uses UI tests to check that the output of the compiler is exactly as expected.
The <code>.stderr</code> file <code>clippy</code> will use to check the newly implemented lint is automatically generated whenever the tests are run using <code>cargo test</code>, but rather than running all of the tests at this point we can run just the test for the individual lint by specifying <code>TESTNAME=ui/naming</code> where <code>ui/naming</code> is the UI test to run:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ TESTNAME<span style="color:#f92672">=</span>ui/naming cargo test --test compile-test
</code></pre></div><p>To update the <code>.stderr</code> (and <code>.stdout</code>, if applicable) files in <code>tests/ui/</code>, we use the provided update script (the correct incantation for an individual lint can be found in the output of <code>cargo test</code> with a specified <code>TESTNAME</code> as we did above):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ tests/ui/update-references.sh <span style="color:#e6db74">&#39;target/debug/test_build_base&#39;</span> <span style="color:#e6db74">&#39;naming.rs&#39;</span>
</code></pre></div><p>This will create the <code>tests/ui/naming.stderr</code> file for the lint.</p>
<h3 id="step-eight-iterate">Step Eight: Iterate</h3>
<p>Now that the bare bones of the lint is implemented and it has <code>stderr</code> output as expected, the lint can be iterated on to add more functionality and identify possible false positives that need to be mitigated.</p>
<p>In the case of this lint, I added test cases that cover the exceptions to the naming rule and then introduced an additional check in the lint to see if the matched function name appeared in this exceptions list:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">const</span> ALLOWED_METHOD_NAMES: [<span style="color:#f92672">&amp;</span>&#39;static <span style="color:#66d9ef">str</span>; <span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> [
    <span style="color:#e6db74">&#34;get&#34;</span>,
    <span style="color:#e6db74">&#34;get_mut&#34;</span>,
    <span style="color:#e6db74">&#34;get_unchecked&#34;</span>,
    <span style="color:#e6db74">&#34;get_unchecked_mut&#34;</span>,
    <span style="color:#e6db74">&#34;get_ref&#34;</span>
];

<span style="color:#66d9ef">impl</span> EarlyLintPass <span style="color:#66d9ef">for</span> GetterPrefix {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">check_impl_item</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">EarlyContext</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;_</span><span style="color:#f92672">&gt;</span>, implitem: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">ast</span>::ImplItem) {
        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> ast::ImplItemKind::Method(..) <span style="color:#f92672">=</span> implitem.node {
            <span style="color:#66d9ef">let</span> name <span style="color:#f92672">=</span> implitem.ident.name.as_str().get();
            <span style="color:#66d9ef">if</span> name.starts_with(<span style="color:#e6db74">&#34;get_&#34;</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>ALLOWED_METHOD_NAMES.contains(<span style="color:#f92672">&amp;</span>name) {
                span_lint(
                    cx,
                    GETTER_PREFIX,
                    implitem.span,
                    <span style="color:#e6db74">&#34;prefixing a getter with `get_` does not follow naming conventions&#34;</span>,
                );
            }
        }
    }
}
</code></pre></div><h3 id="step-nine-run-the-full-test-suite">Step Nine: Run the Full Test Suite</h3>
<p>Up until now I have only been running tests for the lint I have been working on to speed up the feedback cycle.
Before moving on, I want to run the complete test suite to make sure that the tests still pass with my additions, and if any existing lints need to be changed to conform to the new lint.</p>
<p>In doing so I discovered a <code>get_unit</code> function defined in the <a href="https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit"><code>unused_unit</code></a> lint, but since this definition was localized to one lint file I was able to change the function name to pass the getter prefix lint and still maintain the lint&rsquo;s original functionality.
Changing this function name also meant that the <code>tests/ui/unused_unit.stderr</code> file was out of date, which was updated using the provided <code>tests/ui/update-all-references.sh</code> script.</p>
<h3 id="step-ten-linting-clippy-with-local-changes">Step Ten: Linting Clippy with Local Changes</h3>
<p>The last step before submitting a pull request to <a href="https://github.com/rust-lang/rust-clippy">rust-lang/rust-clippy</a> is to make sure that all lints that have already been defined pass <code>clippy</code> (that is, there are no suggestions reported by <code>clippy</code> for its own codebase).
Running <code>clippy</code> locally and addressing any issues found ahead of submitting a pull request will cut down on the feedback cycle and speed up the pull request review process.
The recommended way to do this is by building <code>clippy</code> and then running it with all lint groups (including <code>internal</code> and <code>pedantic</code>) turned on:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ cargo build
$ <span style="color:#e6db74">`</span>pwd<span style="color:#e6db74">`</span>/target/debug/cargo-clippy clippy --all-targets --all-features -- -D clippy::all -D clippy::internal -D clippy::pedantic
</code></pre></div><p>I was not able to run this command successfully, as it resulted in what appear to be dynamic linker errors on my machine:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">$ clippy/target/debug/cargo-clippy --all-targets --all-features -- -D clippy::all -D clippy::internal -D clippy::pedantic
error: failed to run `rustc` to learn about target-specific information

Caused by:
  process didn&#39;t exit successfully: `clippy/target/debug/clippy-driver rustc - --crate-name ___ --print=file-names --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro` (signal: 6, SIGABRT: process abort signal)
--- stderr
dyld: Library not loaded: @rpath/librustc_driver-b630426988dbbdb0.dylib
  Referenced from: clippy/target/debug/clippy-driver
  Reason: image not found
</code></pre></div><p>However, even without running <code>clippy</code> locally, in the case of this getter prefix lint <code>clippy</code> would not pass local <code>clippy</code>.
It turns out that there a number of <code>rustc</code> methods that do not follow the API naming convention, and I will need to consult with other <code>clippy</code> developers to find out if we will need to add more exceptions to the lint than we had originally identified.
The one method that is particularly problematic is <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/trait.LintPass.html#tymethod.get_lints"><code>LintPass::get_lints</code></a> because it appears in every lint that has already been defined in <code>clippy</code>.</p>
<h2 id="submitting-the-lint">Submitting the Lint</h2>
<p>Here&rsquo;s the implemented lint in its entirety:</p>
<p>The UI test file <code>tests/ui/naming.rs</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// Copyright 2018 The Rust Project Developers. See the COPYRIGHT
</span><span style="color:#75715e">// file at the top-level directory of this distribution.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// Licensed under the Apache License, Version 2.0 &lt;LICENSE-APACHE or
</span><span style="color:#75715e">// http://www.apache.org/licenses/LICENSE-2.0&gt; or the MIT license
</span><span style="color:#75715e">// &lt;LICENSE-MIT or http://opensource.org/licenses/MIT&gt;, at your
</span><span style="color:#75715e">// option. This file may not be copied, modified, or distributed
</span><span style="color:#75715e">// except according to those terms.
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyStruct</span> {
    id: <span style="color:#66d9ef">usize</span>
}

<span style="color:#66d9ef">impl</span> MyStruct {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_id</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">usize</span> {
        self.id
    }

    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">usize</span> {
        self.id
    }

    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_mut</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; <span style="color:#66d9ef">usize</span> {
        self.id
    }

    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_unchecked</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">usize</span> {
        self.id
    }

    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_unchecked_mut</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; <span style="color:#66d9ef">usize</span> {
        self.id
    }

    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_ref</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">usize</span> {
        self.id
    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
   <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s <span style="color:#f92672">=</span> MyStruct { id: <span style="color:#ae81ff">42</span> };
   s.get_id();
   s.get();
   s.get_mut();
   s.get_unchecked();
   s.get_unchecked_mut();
   s.get_ref();
}
</code></pre></div><p>The lint implementation <code>clippy_lints/src/naming.rs</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// Copyright 2018 The Rust Project Developers. See the COPYRIGHT
</span><span style="color:#75715e">// file at the top-level directory of this distribution.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// Licensed under the Apache License, Version 2.0 &lt;LICENSE-APACHE or
</span><span style="color:#75715e">// http://www.apache.org/licenses/LICENSE-2.0&gt; or the MIT license
</span><span style="color:#75715e">// &lt;LICENSE-MIT or http://opensource.org/licenses/MIT&gt;, at your
</span><span style="color:#75715e">// option. This file may not be copied, modified, or distributed
</span><span style="color:#75715e">// except according to those terms.
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};
<span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::rustc::{declare_tool_lint, lint_array};
<span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::syntax::ast;
<span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::utils::span_lint;

<span style="color:#e6db74">/// **What it does:** Checks for the `get_` prefix on getters.
</span><span style="color:#e6db74">///
</span><span style="color:#e6db74">/// **Why is this bad?** The Rust API Guidelines section on naming
</span><span style="color:#e6db74">/// [specifies](https://rust-lang-nursery.github.io/api-guidelines/naming.html#getter-names-follow-rust-convention-c-getter)
</span><span style="color:#e6db74">/// that the `get_` prefix is not used for getters in Rust code unless
</span><span style="color:#e6db74">/// there is a single and obvious thing that could reasonably be gotten by
</span><span style="color:#e6db74">/// a getter.
</span><span style="color:#e6db74">///
</span><span style="color:#e6db74">/// The exceptions to this naming convention are as follows:
</span><span style="color:#e6db74">/// - `get` (such as in
</span><span style="color:#e6db74">///   [`std::cell::Cell::get`](https://doc.rust-lang.org/std/cell/struct.Cell.html#method.get))
</span><span style="color:#e6db74">/// - `get_mut`
</span><span style="color:#e6db74">/// - `get_unchecked`
</span><span style="color:#e6db74">/// - `get_unchecked_mut`
</span><span style="color:#e6db74">/// - `get_ref`
</span><span style="color:#e6db74">///
</span><span style="color:#e6db74">/// **Known problems:** None.
</span><span style="color:#e6db74">///
</span><span style="color:#e6db74">/// **Example:**
</span><span style="color:#e6db74">///
</span><span style="color:#e6db74">/// ```rust
</span><span style="color:#e6db74">/// // Bad
</span><span style="color:#e6db74">/// impl B {
</span><span style="color:#e6db74">///     fn get_id(&amp;self) -&gt; usize {
</span><span style="color:#e6db74">///         ..
</span><span style="color:#e6db74">///     }
</span><span style="color:#e6db74">/// }
</span><span style="color:#e6db74">///
</span><span style="color:#e6db74">/// // Good
</span><span style="color:#e6db74">/// impl G {
</span><span style="color:#e6db74">///     fn id(&amp;self) -&gt; usize {
</span><span style="color:#e6db74">///         ..
</span><span style="color:#e6db74">///     }
</span><span style="color:#e6db74">/// }
</span><span style="color:#e6db74">///
</span><span style="color:#e6db74">/// // Also allowed
</span><span style="color:#e6db74">/// impl A {
</span><span style="color:#e6db74">///     fn get(&amp;self) -&gt; usize {
</span><span style="color:#e6db74">///         ..
</span><span style="color:#e6db74">///     }
</span><span style="color:#e6db74">/// }
</span><span style="color:#e6db74">/// ```
</span><span style="color:#e6db74"></span>declare_clippy_lint<span style="color:#f92672">!</span> {
    <span style="color:#66d9ef">pub</span> GETTER_PREFIX,
    style,
    <span style="color:#e6db74">&#34;prefixing a getter with `get_`, which does not follow convention&#34;</span>
}

<span style="color:#75715e">#[derive(Copy, Clone)]</span>
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">GetterPrefix</span>;

<span style="color:#75715e">#[rustfmt::skip]</span>
<span style="color:#66d9ef">const</span> ALLOWED_METHOD_NAMES: [<span style="color:#f92672">&amp;</span>&#39;static <span style="color:#66d9ef">str</span>; <span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> [
    <span style="color:#e6db74">&#34;get&#34;</span>,
    <span style="color:#e6db74">&#34;get_mut&#34;</span>,
    <span style="color:#e6db74">&#34;get_unchecked&#34;</span>,
    <span style="color:#e6db74">&#34;get_unchecked_mut&#34;</span>,
    <span style="color:#e6db74">&#34;get_ref&#34;</span>
];

<span style="color:#66d9ef">impl</span> LintPass <span style="color:#66d9ef">for</span> GetterPrefix {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_lints</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">LintArray</span> {
        lint_array<span style="color:#f92672">!</span>(GETTER_PREFIX)
    }
}

<span style="color:#66d9ef">impl</span> EarlyLintPass <span style="color:#66d9ef">for</span> GetterPrefix {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">check_impl_item</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">EarlyContext</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;_</span><span style="color:#f92672">&gt;</span>, implitem: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">ast</span>::ImplItem) {
        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> ast::ImplItemKind::Method(..) <span style="color:#f92672">=</span> implitem.node {
            <span style="color:#66d9ef">let</span> name <span style="color:#f92672">=</span> implitem.ident.name.as_str().get();
            <span style="color:#66d9ef">if</span> name.starts_with(<span style="color:#e6db74">&#34;get_&#34;</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>ALLOWED_METHOD_NAMES.contains(<span style="color:#f92672">&amp;</span>name) {
                span_lint(
                    cx,
                    GETTER_PREFIX,
                    implitem.span,
                    <span style="color:#e6db74">&#34;prefixing a getter with `get_` does not follow naming conventions&#34;</span>,
                );
            }
        }
    }
}
</code></pre></div><p>Once the basic lint functionality was completed, I wanted to open a pull request against <a href="https://github.com/rust-lang/rust-clippy">rust-lang/rust-clippy</a> as soon as possible.
This is my first time writing a lint for <code>clippy</code>, so I wanted to start getting feedback from other <code>clippy</code> developers and incorporate their suggestions to improve the lint code as well as my understanding of how <code>clippy</code> works.
Once I got the lint working I also realized there were a number of decisions to be made where I did not have enough Rust ecosystem or <code>clippy</code>-specific knowledge to answer, so opening a pull request would be a great way to get those questions answered within the context of the code I had written for the lint.</p>
<p>My pull request for this getter prefix name lint can be found at <a href="https://github.com/rust-lang/rust-clippy/pull/3616">rust-lang/rust-clippy#3616</a> which details the current state of the lint implementation and its progress getting merged into <code>clippy</code>.</p>
<p>There is still some work to be done before I feel confident this lint can be merged.
First, I need to go through <code>clippy</code> more thoroughly and identify existing lints that need to be changed to pass the newly introduced lint; resolving the error I identified in <a href="#step-ten-linting-clippy-with-local-changes">Step Ten</a> should get me well on the way to achieving this.</p>
<p>I would also like to implement some machine-applicable renaming suggestions that would remove the <code>get_</code> prefix from method names so that functions that fail to meet this Rust API naming convention can be automatically fixed by <code>rustfix</code>.
I&rsquo;m looking into the mechanisms <code>clippy</code> provides to make these kinds of suggestions, and <a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/utils/mod.rs#L679"><code>span_lint_and_sugg</code></a> looks like a likely candidate for teaching <code>rustfix</code> about these renaming rules.</p>
<p>Lastly I will of course need to implement the feedback on the pull request from other <code>clippy</code> developers so the lint will be accepted for inclusion in <code>clippy</code>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I&rsquo;m really glad I was able to write this lint for <code>clippy</code>.
I had found the original issue, <a href="https://github.com/rust-lang/rust-clippy/issues/1673">rust-lang/rust-clippy#1673</a>, back in October 2018 and thought it was the perfect size for getting my feet wet writing a lint.
Some parts of implementing this lint turned out to be more difficult than I had anticipated, most notably around the sparseness or complete lack of <code>rustc</code> internals documentation which was surprising given the Rust community&rsquo;s focus on writing documentation and the generally high quality documentation available across the ecosystem, but a little trial and error and some <code>println!</code> debugging pointed me in the right direction in the end.</p>
<p>A special thanks to <a href="https://manishearth.github.io/">Manish Goregaokar</a>, <a href="https://github.com/flip1995">Philipp Krones</a>, <a href="https://github.com/matthiaskrgr">Matthias Krger</a>, and <a href="https://github.com/hcpl">hcpl</a> for their input, feedback, and help at various points throughout this process, and <a href="https://llogiq.github.io/">llogiq</a> for their blog post on <a href="https://llogiq.github.io/2015/06/04/workflows.html">writing <code>clippy</code> lints</a> which was very helpful in finding my way to a working lint implementation.</p>
<p>There is a particular quote by Charles H. Spurgeon that I tend to associate with new years and new beginnings: &ldquo;Begin as you mean to go on, and go on as you began&rdquo;.
The way that I began 2019 was writing Rust code, and I fully intend to go on writing Rust code for the rest of 2019 and beyond.
I think that&rsquo;s a worth-while New Year&rsquo;s resolution, don&rsquo;t you?</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">06 Dec 2018</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://stuartcrust.com/2018/12/yak-shaving-in-f/" class="post-title">Yak Shaving in F</a>

                        <p class="post-meta">
                            
                            
    under 
    <a class="post-category post-category-open-source" href='/categories/open-source'>open source</a><a class="post-category post-category-rust" href='/categories/rust'>rust</a><a class="post-category post-category-clippy" href='/categories/clippy'>clippy</a>


                        </p>
                    </header>

                    <div class="post-description">
                        <p>Following on from my <a href="/2018/11/i-see-you-are-writing-some-rust">introduction to <code>clippy</code> lints</a>, this week I am beginning my journey of actually implementing a <code>clippy</code> lint.</p>
<p>As a refresher, I am implementing <a href="https://github.com/rust-lang/rust-clippy/issues/1673"><code>rust-lang/rust-clippy#1673</code></a>:</p>
<blockquote>
<p>To summarize, if the type has a <code>get_foo</code> method we should suggest naming it <code>foo</code> instead to follow the API Guidelines for <a href="https://rust-lang-nursery.github.io/api-guidelines/naming.html#c-getter">Rust getter name conventions</a> <em>except</em> for cases of:</p>
<ul>
<li><code>get</code></li>
<li><code>get_mut</code></li>
<li><code>get_unchecked</code></li>
<li><code>get_unchecked_mut</code></li>
<li><code>get_ref</code></li>
</ul>
<p>This should be enough to get me started on a style lint for this convention, I should have some time over the next couple days to start digging into this.</p>
</blockquote>
<h2 id="clippys-author-lint"><code>clippy</code>&rsquo;s Author Lint</h2>
<p>In typical TDD fashion, I want to start with the test case, the code I want to lint against, so I can test my implementation and drive design.
I&rsquo;ve started off with the simple case of detecting the invalid style rather than worrying about whitelisting the exceptions identified.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyStruct</span> {
    id: <span style="color:#66d9ef">u32</span>
}

<span style="color:#66d9ef">impl</span> MyStruct {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_id</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">u32</span> {
        self.id
    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
   <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> MyStruct { id: <span style="color:#ae81ff">42</span> };

   <span style="color:#75715e">#[clippy::author]</span>
   <span style="color:#66d9ef">let</span> id <span style="color:#f92672">=</span> s.get_id();
}
</code></pre></div><p>I&rsquo;ve also added the <code>#[clippy::author]</code> annotation as <a href="https://github.com/rust-lang/rust-clippy/blob/master/CONTRIBUTING.md#author-lint">suggested by <code>clippy</code>&rsquo;s contributing documentation</a> to generate a starting point for the lint.</p>
<p>Next, I have to run the test to produce a <code>.stdout</code> file with the code generated by the <code>#[clippy::author]</code> lint. The instructions say:</p>
<blockquote>
<p>If the command was executed successfully, you can copy the code over to where you are implementing your lint.</p>
</blockquote>
<p>Let&rsquo;s try it out:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">$ TESTNAME=ui/getter_prefix cargo test --test compile-test
    Finished dev [unoptimized + debuginfo] target(s) in 0.15s
     Running target/debug/deps/compile_test-f89d0316ceade355

running 1 test

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 29 filtered out


running 1 test
test [ui] ui/getter_prefix.rs ... FAILED

failures:

---- [ui] ui/getter_prefix.rs stdout ----
normalized stdout:
if_chain! {
    if let StmtKind::Decl(ref decl, _) = stmt.node
    if let DeclKind::Local(ref local) = decl.node;
    if let Some(ref init) = local.init
    if let ExprKind::MethodCall(ref method_name, ref generics, ref args) = init.node;
    // unimplemented: `ExprKind::MethodCall` is not further destructured at the moment
    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.node;
    if name.node.as_str() == &#34;id&#34;;
    then {
        // report your lint here
    }
}


expected stdout:


diff of stdout:

+if_chain! {
+    if let StmtKind::Decl(ref decl, _) = stmt.node
+    if let DeclKind::Local(ref local) = decl.node;
+    if let Some(ref init) = local.init
+    if let ExprKind::MethodCall(ref method_name, ref generics, ref args) = init.node;
+    // unimplemented: `ExprKind::MethodCall` is not further destructured at the moment
+    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.node;
+    if name.node.as_str() == &#34;id&#34;;
+    then {
+        // report your lint here
+    }
+}
+

The actual stdout differed from the expected stdout.
Actual stdout saved to /Users/scrust/devel/rust-clippy/target/debug/test_build_base/getter_prefix.stdout
To update references, run this command from build directory:
tests/ui/update-references.sh &#39;/Users/scrust/devel/rust-clippy/target/debug/test_build_base&#39; &#39;getter_prefix.rs&#39;

error: 1 errors occurred comparing output.
status: exit code: 0
command: &#34;target/debug/clippy-driver&#34; &#34;tests/ui/getter_prefix.rs&#34; &#34;-L&#34; &#34;/Users/scrust/devel/rust-clippy/target/debug/test_build_base&#34; &#34;--target=x86_64-apple-darwin&#34; &#34;-C&#34; &#34;prefer-dynamic&#34; &#34;-o&#34; &#34;/Users/scrust/devel/rust-clippy/target/debug/test_build_base/getter_prefix.stage-id&#34; &#34;-L&#34; &#34;target/debug&#34; &#34;-L&#34; &#34;target/debug/deps&#34; &#34;-Dwarnings&#34; &#34;-L&#34; &#34;/Users/scrust/devel/rust-clippy/target/debug/test_build_base/getter_prefix.stage-id.aux&#34; &#34;-A&#34; &#34;unused&#34;
stdout:
------------------------------------------
if_chain! {
    if let StmtKind::Decl(ref decl, _) = stmt.node
    if let DeclKind::Local(ref local) = decl.node;
    if let Some(ref init) = local.init
    if let ExprKind::MethodCall(ref method_name, ref generics, ref args) = init.node;
    // unimplemented: `ExprKind::MethodCall` is not further destructured at the moment
    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.node;
    if name.node.as_str() == &#34;id&#34;;
    then {
        // report your lint here
    }
}

------------------------------------------
stderr:
------------------------------------------

------------------------------------------

thread &#39;[ui] ui/getter_prefix.rs&#39; panicked at &#39;explicit panic&#39;, /Users/scrust/.cargo/registry/src/github.com-1ecc6299db9ec823/compiletest_rs-0.3.17/src/runtest.rs:2553:9
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    [ui] ui/getter_prefix.rs

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 225 filtered out

test compile_test ... FAILED

failures:

---- compile_test stdout ----
thread &#39;compile_test&#39; panicked at &#39;Some tests failed&#39;, /Users/scrust/.cargo/registry/src/github.com-1ecc6299db9ec823/compiletest_rs-0.3.17/src/lib.rs:89:22


failures:
    compile_test

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass &#39;--test compile-test&#39;
</code></pre></div><p>Wow that&rsquo;s a lot out output.
More importantly, I don&rsquo;t actually know if it worked.
I see</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 29 filtered out
</code></pre></div><p>but then I see</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">The actual stdout differed from the expected stdout.
Actual stdout saved to /Users/scrust/devel/rust-clippy/target/debug/test_build_base/getter_prefix.stdout
</code></pre></div><p>and</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 225 filtered out

test compile_test ... FAILED
</code></pre></div><p>I also don&rsquo;t see any generated <code>.stdout</code> file, so I&rsquo;m going to assume there&rsquo;s something wrong with my test case.</p>
<p>If I remove the author lint tag, I get a different result:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">$ TESTNAME=ui/getter_prefix cargo test --test compile-test
    Finished dev [unoptimized + debuginfo] target(s) in 0.16s
     Running target/debug/deps/compile_test-f89d0316ceade355

running 1 test

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 29 filtered out


running 1 test
test [ui] ui/getter_prefix.rs ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 225 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

test compile_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre></div><p>This all seems to pass, but I still don&rsquo;t see a generated <code>.stdout</code> file, and I&rsquo;ve also lost any output the <code>#[clippy:author]</code> annotation would have given me.</p>
<p>I noticed a line from the earlier, possibly failed, test run:</p>
<blockquote>
<p>To update references, run this command from build directory:
tests/ui/update-references.sh &lsquo;/Users/scrust/devel/rust-clippy/target/debug/test_build_base&rsquo; &lsquo;getter_prefix.rs&rsquo;</p>
</blockquote>
<p>What does this do?
What&rsquo;s a &ldquo;reference&rdquo;?
<code>clippy</code>&rsquo;s documentation doesn&rsquo;t seem to mention <code>tests/ui/update-references.sh</code> at all, though there is a mention of <code>tests/ui/update-all-references.sh</code> which seems to update all of the existing <code>.stderr</code> files that drive the UI tests.</p>
<p>It turns out that running <code>tests/ui/update-references.sh</code> is necessary to actually write the <code>.stdout</code> file.
I wasn&rsquo;t expecting this extra step because the way the instructions are phrased I though running the test would generate the <code>.stdout</code> file automatically.
For the test I wrote, <code>#[clippy::author]</code> generated a <code>.stdout</code> file with the following code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">if_chain! {
    if let StmtKind::Decl(ref decl, _) = stmt.node
    if let DeclKind::Local(ref local) = decl.node;
    if let Some(ref init) = local.init
    if let ExprKind::MethodCall(ref method_name, ref generics, ref args) = init.node;
    // unimplemented: `ExprKind::MethodCall` is not further destructured at the moment
    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.node;
    if name.node.as_str() == &#34;id&#34;;
    then {
        // report your lint here
    }
}
</code></pre></div><p>I&rsquo;m not at all familiar with the <code>if_chain!</code> macro or any of these datatypes, so I definitely have some reading to do so I can understand what this snippet actually does.
I do see <code>if name.node.as_str() == &quot;id&quot;;</code> which seems to match the <code>id</code> field on <code>MyStruct</code> which is about the only piece I understand without delving deeper.</p>
<p>Out of curiosity after reading a number of other lint tests, I decided to update main and added an assert statement:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
   <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> MyStruct { id: <span style="color:#ae81ff">42</span> };

    <span style="color:#75715e">#[clippy::author]</span>
    <span style="color:#66d9ef">let</span> id <span style="color:#f92672">=</span> s.get_id();

    assert_eq<span style="color:#f92672">!</span>(id, <span style="color:#ae81ff">42</span>);
}
</code></pre></div><p>and got yet another different result:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">$ TESTNAME=ui/getter_prefix cargo test --test compile-test
    Finished dev [unoptimized + debuginfo] target(s) in 0.16s
     Running target/debug/deps/compile_test-f89d0316ceade355

running 1 test

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 29 filtered out


running 1 test
test [ui] ui/getter_prefix.rs ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 225 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

test compile_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre></div><p>I&rsquo;m not sure the <code>#[clippy::author]</code> annotation is going to help me too much in implementing this lint.
Right now I don&rsquo;t know enough about <code>clippy</code> or the datatypes it uses to make heads or tails of the generated code, and the results of my test are inconsistent depending on various combinations of <code>assert_eq!</code> and the author annotation.
This definitely calls for more research, so until next week it looks like I&rsquo;ll be getting to grips with some of <code>rustc</code>&rsquo;s compiler internals.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">25 Nov 2018</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://stuartcrust.com/2018/11/i-see-you-are-writing-some-rust/" class="post-title">I See You Are Writing Some Rust</a>

                        <p class="post-meta">
                            
                            
    under 
    <a class="post-category post-category-open-source" href='/categories/open-source'>open source</a><a class="post-category post-category-rust" href='/categories/rust'>rust</a><a class="post-category post-category-clippy" href='/categories/clippy'>clippy</a>


                        </p>
                    </header>

                    <div class="post-description">
                        <h1 id="would-you-like-some-help-with-that">Would You Like Some Help With That?</h1>
<p>In my <a href="/2018/11/opinionated-formatting">last post</a> I wrote a bit about code linting and code formatting, particularly in more modern programming languages like Rust and Go where such tools come first-class as part of the language&rsquo;s toolchain.
In addition to Rust&rsquo;s <code>rustfmt</code> tool which formats Rust code according to style guidelines, Rust&rsquo;s ecosystem also has a tool called <code>clippy</code> which is a much more opinionated tool &ldquo;to catch common mistakes and improve your Rust code.&rdquo;</p>
<h2 id="introducing-clippy">Introducing <code>clippy</code></h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text"> _____________________________________
/ I see you are writing some Rust.    \
\ Would you like some help with that? /
 -------------------------------------
 \
  \
    /  \
    |  |
    @  @
    |  |
    || |/
    || ||
    |\_/|
    \___/
</code></pre></div><p><code>clippy</code> currently has <a href="https://rust-lang.github.io/rust-clippy/master/index.html">288 lints</a> to help developers write better Rust code.
The lints are broken down into various categories such as:</p>
<ul>
<li>style: code that should be written in a more idiomatic way (e.g. <code>if x.len() == 0 {...}</code> could be re-written as <code>if x.is_empty() {...}</code>)</li>
<li>correctness: code that it outright wrong of very useless (e.g. ensuring syntax when creating regexes)</li>
<li>complexity: code that is more complex than necessary (e.g. <code>if x == true {...}</code> could be re-written as <code>if x {...}</code>)</li>
</ul>
<p>as well as <a href="https://github.com/rust-lang/rust-clippy#clippy">many others</a>.</p>
<p>I&rsquo;ve been interested in contributing to a Rust tooling project since I did my <a href="/2018/10/hacktoberfest-week-one/">initial Rust project overview</a> as part of <a href="/categories/hacktoberfest/">Hacktoberfest 2018</a>.
Good tooling is a <a href="https://en.wikipedia.org/wiki/Force_multiplication">force multiplier</a> in software development, and improving tooling - especially tooling that is &ldquo;blessed&rdquo; and supported by the core language team - can reach so many more people than small purpose-built tools set up for individual projects.</p>
<p>During Hacktoberfest, I ran across <a href="https://github.com/rust-lang/rust-clippy/issues/1673"><code>rust-lang/rust-clippy#1673</code></a> but because of the time constraints on Hacktoberfest contributions along with my other coursework I didn&rsquo;t have time to claim the issue.</p>
<p>The full issue is as follows:</p>
<blockquote>
<p>It is not idiomatic in Rust to have setters and getters. Make the field public instead.
If the type only has a <code>get_foo</code> method but not a <code>set_foo</code> method, suggest naming it <code>foo</code> instead.</p>
</blockquote>
<p>This seemed like a relatively simple lint to implement which would hopefully introduce me to a number of features <code>clippy</code> uses when analyzing Rust code and inspecting the representation that the <code>rustc</code> compiler sees before it generates build artifacts.
Once Hacktoberfest was over and I cleared some work off my plate, I went back and asked if the lint <a href="https://github.com/rust-lang/rust-clippy/issues/1673#issuecomment-440137309">was still up for grabs</a> before I invested the time to attempt an implementation.
<a href="https://twitter.com/Manishearth">Manish Goregaokar</a> of the <a href="https://www.rust-lang.org/en-US/team.html#Dev-tools-team">Rust dev tools team</a> got back to me almost immediately:</p>
<blockquote>
<p>Actually, I&rsquo;m not sure if this really is valid rust style &ndash; setters and getters may be added to future proof an API, for example.</p>
</blockquote>
<p>Manish raised the excellent point that getters and setters are in fact valid Rust style and I agreed, so I thought I was going to have to find another issue to work on and moved to <a href="https://github.com/rust-lang/rust-clippy/issues/1673#issuecomment-440436914">close the issue</a>.</p>
<p>I was worried that I would run into a similar situation with other issues I was interested in working on, so I reached out to Manish directly on the <code>wg-clippy</code> Discord channel and asked about another issue I was interested in working on:</p>
<blockquote>
<p>@manishearth i was interested in picking up <a href="https://github.com/rust-lang/rust-clippy/issues/1673">https://github.com/rust-lang/rust-clippy/issues/1673</a> but i agree with your comment that it may not be a desirable lint to have</p>
<p>i&rsquo;m looking at <a href="https://github.com/rust-lang/rust-clippy/issues/2144">https://github.com/rust-lang/rust-clippy/issues/2144</a> now, or if there&rsquo;s another <code>good first issue</code> that&rsquo;s up for grabs i&rsquo;d definitely be interested in taking a look!</p>
</blockquote>
<p>I got a response pretty quickly:</p>
<blockquote>
<p>that seems fine!</p>
</blockquote>
<p>However, activity on the original issue I was interested in had clearly caught some attention, and I got into a discussion with user <a href="https://github.com/hcpl">hcpl</a> about other use cases for the lint, specifically:</p>
<blockquote>
<p>If the type only has a <code>get_foo</code> method but not a <code>set_foo</code> method, suggest naming it <code>foo</code> instead.</p>
</blockquote>
<p>It <a href="https://github.com/rust-lang/rust-clippy/issues/1673#issuecomment-440460968">turned out</a> that there was already some precedence for this style in the Rust standard library, and the Rust API Guidelines has an <a href="https://rust-lang-nursery.github.io/api-guidelines/naming.html#c-getter">entire section</a> about Rust conventions for getter names. Except for the cases of:</p>
<ul>
<li><code>get</code></li>
<li><code>get_mut</code></li>
<li><code>get_unchecked</code></li>
<li><code>get_unchecked_mut</code></li>
<li><code>get_ref</code></li>
</ul>
<p>which have some special meanings in Rust related to <a href="https://doc.rust-lang.org/book/second-edition/ch03-01-variables-and-mutability.html">data mutability</a>, references, or <a href="https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html">unsafe code</a>, the <code>get_</code> prefix is not generally used in Rust.
Searching for these exceptions also turned up an <a href="https://github.com/rust-lang/rust/issues/27745">unstable feature relating to <code>TypeId</code></a> to support <a href="https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29">reflection</a> that <em>does</em> include the <code>get_</code> prefix even though it&rsquo;s <a href="https://github.com/rust-lang/rust/issues/27745#issuecomment-138511187">not supposed to</a>, which goes to show that implementing this lint could be very valuable to help maintain style even in core Rust projects and the compiler.</p>
<p>After some good back-and-forth discussion with <a href="https://github.com/hcpl">hcpl</a> and <a href="https://github.com/flip1995">Philipp Krones</a>, I <a href="https://github.com/rust-lang/rust-clippy/issues/1673#issuecomment-441304062">summarized the proposed refinements</a> to the filed issue:</p>
<blockquote>
<p>To summarize, if the type has a <code>get_foo</code> method we should suggest naming it <code>foo</code> instead to follow the API Guidelines for <a href="https://rust-lang-nursery.github.io/api-guidelines/naming.html#c-getter">Rust getter name conventions</a> <em>except</em> for cases of:</p>
<ul>
<li><code>get</code></li>
<li><code>get_mut</code></li>
<li><code>get_unchecked</code></li>
<li><code>get_unchecked_mut</code></li>
<li><code>get_ref</code></li>
</ul>
<p>This should be enough to get me started on a style lint for this convention, I should have some time over the next couple days to start digging into this.</p>
</blockquote>
<p>With better clarity on what the lint should implement as well as some known exceptions, I was in a position to start getting the project set up and go through all the steps of onboarding onto a new project.</p>
<h2 id="working-on-clippy">Working on <code>clippy</code></h2>
<p>To start implementing the lint, I had to go through all the usual steps of forking and cloning <code>clippy</code> and making sure I could build the project locally before I could start digging into code.
After cloning the project, I went ahead and tried to build <code>clippy</code> locally:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">$ cargo --version
cargo 1.32.0-nightly (1fa308820 2018-10-31)

$ cargo build

[snip]

error[E0050]: method `check_pat` has 4 parameters but the declaration in trait `rustc::lint::EarlyLintPass::check_pat` has 3
   --&gt; clippy_lints/src/misc_early.rs:244:66
    |
244 |     fn check_pat(&amp;mut self, cx: &amp;EarlyContext&lt;&#39;_&gt;, pat: &amp;Pat, _: &amp;mut bool) {
    |                                                                  ^^^^^^^^^ expected 3 parameters, found 4
    |
    = note: `check_pat` from trait: `fn(&amp;mut Self, &amp;rustc::lint::EarlyContext&lt;&#39;_&gt;, &amp;syntax::ast::Pat)`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0050`.
error: Could not compile `clippy_lints`.
warning: build failed, waiting for other jobs to finish...
error: build failed
</code></pre></div><p>Oops, that&rsquo;s not good.
I knew <code>clippy</code> relied heavily on features from the <code>nightly</code> release channel, and, as the name implies, the <code>nightly</code> channel is released every night with new changes and improvements.
<code>clippy</code> must be making use of some new feature here and my <code>nightly</code> Rust is out of date.
I updated Rust with <code>rustup</code> and then tried again to build <code>clippy</code> locally:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">$ rustup update

[snip]

nightly-x86_64-apple-darwin updated - rustc 1.32.0-nightly (5aff30734 2018-11-19)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">$ cargo --version
cargo 1.32.0-nightly (b3d0b2e54 2018-11-15)

$ cargo build

[snip]

Finished dev [unoptimized + debuginfo] target(s) in 2m 03s
</code></pre></div><p>Now that I knew I really had to watch the versions and make sure everything was up to date, I was ready to start thinking about implementing the lint.</p>
<h3 id="a-few-days-later">A Few Days Later&hellip;</h3>
<p>A challenge that I&rsquo;ve been running into working on <code>clippy</code> is that because it relies so heavily on <code>nightly</code> compiler features, and both <code>clippy</code> and <code>nightly</code> are moving targets, my local <code>clippy</code> checkout can very quickly get out of date not only from upstream but also from the <code>nightly</code> release channel.</p>
<p>For example, I updated everything recently and got:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">$ cargo build

   Compiling clippy_lints v0.0.212 (/Users/azure/devel/rust-clippy/clippy_lints)
error[E0615]: attempted to take value of method `abi` on type `rustc_target::abi::Align`
    --&gt; clippy_lints/src/types.rs:1067:93
     |
1067 |                 if let Some(from_align) = cx.layout_of(from_ptr_ty.ty).ok().map(|a| a.align.abi);
     |                                                                                             ^^^
     |
     = help: maybe a `()` to call it is missing?

error[E0615]: attempted to take value of method `abi` on type `rustc_target::abi::Align`
    --&gt; clippy_lints/src/types.rs:1068:89
     |
1068 |                 if let Some(to_align) = cx.layout_of(to_ptr_ty.ty).ok().map(|a| a.align.abi);
     |                                                                                         ^^^
     |
     = help: maybe a `()` to call it is missing?

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0615`.
error: Could not compile `clippy_lints`.
</code></pre></div><p>which is the change introduced in <a href="https://github.com/rust-lang/rust-clippy/pull/3452">rust-lang/rust-clippy#3452</a>.</p>
<p>For whatever reason, even after updating Rust and using the same tool versions as in <a href="https://travis-ci.org/rust-lang/rust-clippy/builds/458715770">this passing test</a> for the above pull request the project does not build locally.
Luckily reverting back to <a href="https://github.com/rust-lang/rust-clippy/pull/3449"><code>61501b2810d887367d360025398dd9280c4bcd8b</code></a> lets me compile the project so I can continue working without getting <em>too</em> out of date with upstream, but there&rsquo;s a lot of churn and things often break for unexplained reasons.</p>
<p>I reached out to <a href="https://github.com/matthiaskrgr">Matthias Krger</a>, the original author of <code>#3453</code>, on the <code>wg-rust</code> Discord channel to find out what was going on.
It turns out that sometimes even the <code>nightly</code> release channel isn&rsquo;t <a href="https://en.wikipedia.org/wiki/Bleeding_edge_technology">bleeding-edge</a> enough to work on <code>clippy</code> lints and a tool called <a href="https://github.com/kennytm/rustup-toolchain-install-master"><code>rustup-toolchain-install-master</code></a> is necessary to install compiler artifacts directly from Rust&rsquo;s continuous integration pipeline that haven&rsquo;t even been published to the <code>nightly</code> channel yet.
This information is also documented in <code>clippy</code>&rsquo;s <a href="https://github.com/rust-lang/rust-clippy/blob/master/CONTRIBUTING.md#fixing-build-failures-caused-by-rust"><code>CONTRIBUTING.MD</code> file</a>, but it&rsquo;s located at almost the bottom of the document which is why I hadn&rsquo;t run across the information earlier.
It is very true that it pays to read the documentation, and in many other projects asking a question about why my local build was failing in this way would receive comments to &ldquo;<a href="https://en.wikipedia.org/wiki/RTFM">RTFM</a>&rdquo;.
However, my experiences in the Rust community have been nothing but positive, everyone I have interacted with has been very helpful, and even &ldquo;big names&rdquo; in the community are accessible and directly engaged in projects and contributor mentorship.</p>
<h2 id="to-be-continued">To Be Continued&hellip;</h2>
<p>This week was all about finding my footing and getting my local environment set up to actually do development work on <code>clippy</code>.
In the coming weeks I&rsquo;ll tackle actually implementing the lint now that the requirements and goals have been fleshed out, and I hope to have something up for code review soon to get community feedback on improving the lint and catching anything I&rsquo;ve missed.</p>
<p>First up: reading <a href="https://twitter.com/llogiq">llogiq</a>&rsquo;s blogpost on <a href="https://llogiq.github.io/2015/06/04/workflows.html">writing <code>clippy</code> lints</a>.
Then I&rsquo;ll create a starting point for my lint with <a href="https://github.com/rust-lang/rust-clippy/blob/master/CONTRIBUTING.md#author-lint"><code>clippy</code>&rsquo;s internal <code>author</code> lint</a> as well as reading some <a href="https://github.com/rust-lang/rust-clippy/tree/master/clippy_lints/src">existing lints</a> to get a general idea of lint structure.</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">18 Nov 2018</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://stuartcrust.com/2018/11/opinionated-formatting/" class="post-title">Opinionated Formatting</a>

                        <p class="post-meta">
                            
                            
    under 
    <a class="post-category post-category-open-source" href='/categories/open-source'>open source</a><a class="post-category post-category-code-linting" href='/categories/code-linting'>code linting</a><a class="post-category post-category-code-formatting" href='/categories/code-formatting'>code formatting</a><a class="post-category post-category-rust" href='/categories/rust'>rust</a><a class="post-category post-category-clippy" href='/categories/clippy'>clippy</a>


                        </p>
                    </header>

                    <div class="post-description">
                        <p>This week in class we talked about code linting and code formatting using <a href="https://eslint.org/">ESLint</a> and <a href="https://prettier.io/">Prettier</a>.
These kinds of tools automate a lot of the otherwise labour-intensive and easy-to-miss nitpicks reviewers often leave on pull requests, freeing up time to review much more important elements such as design and code structure.
Many tech companies - <a href="https://google.github.io/styleguide/">Google</a>, <a href="http://airbnb.io/javascript/">AirBnB</a>, <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions">Microsoft</a> to name a few - have their own code style guides, much in the same way that writing organizations (<a href="https://www.bbc.co.uk/academy/en/collections/news-style-guide">news organizations</a> and <a href="https://www.apastyle.org/">scientific publishing</a>, for example) have documents that outline how to maintain consistency in publications across many hundreds of outlets and thousands of writers, and the idea of a style guide is not new.
However, the idea of automating this style checking to help developers maintain a consistent style has gained a lot more traction in recent years thanks in part to style and formatting tools coming standard and enabled by default in many modern programming languages.</p>
<h2 id="formatting-as-a-first-class-tool">Formatting as a First-Class Tool</h2>
<p>I was first exposed to this idea of a universal formatter as part of a language&rsquo;s toolchain when I started experimenting with <a href="https://golang.org/">Go</a>.
Go&rsquo;s <a href="https://golang.org/cmd/gofmt/"><code>gofmt</code></a> enforces a consistent style not just within one project, but across the <em>entire</em> ecosystem of Go code, making even foreign codebases more accessible because of their consistent style.
This consistency helps to reduce visual noise, making it easier to focus on what the code says rather than how it&rsquo;s formatted.
This idea of a universal formatter appears in other languages like <a href="https://www.rust-lang.org">Rust</a>&rsquo;s own <a href="https://github.com/rust-lang-nursery/rustfmt"><code>rustfmt</code></a>, though there are many other tools for enforcing style that predate these tools, such as <a href="https://www.rubocop.org/en/latest/">rubocop</a> for Ruby and <a href="http://astyle.sourceforge.net/">astyle</a> for C and C++.</p>
<p>In Go and Rust, these formatters increase productivity dramatically because as long as you write syntactically correct code, it can be the ugliest code you have ever written and by passing it through the formatter (and many editors and IDEs will even format the source for you when you save!) you can leave it up to the formatter to make the code pretty and readable.
This means less time fiddling with alignment, worrying about indentation, and dithering over where to break your function call chain to best communicate your intent.
It also means that wars over format like <a href="https://www.businessinsider.com/tabs-vs-spaces-from-silicon-valley-2016-5">tabs versus spaces</a> are dead; the formatter is the absolute arbitrator of the correct style, and because the formatter is consistent across the entire ecosystem there is a lot of pressure for users to conform instead of trying to tweak the formatter to their own personal preferences.</p>
<p>We still have an <a href="https://github.com/0xazure/supernova/issues/21">open issue</a> on <code>supernova</code> for implementing <code>rustfmt</code> as part of our continuous integration process that we hope to close out with a pull request relatively soon so we can be sure all the code contributed to <code>supernova</code> follows the same format as other projects.</p>
<h2 id="build-infrastructure-weirdness">Build Infrastructure Weirdness</h2>
<p>Speaking of our continuous integration process, we ran into a very curious issue with <a href="https://github.com/0xazure/supernova/pull/24"><code>0xazure/supernova#24</code></a> this week where our builds started failing on the <code>beta</code> release channel.
The build failure is caused by <code>clippy</code>&rsquo;s <a href="https://rust-lang-nursery.github.io/rust-clippy/current/index.html#new_ret_no_self"><code>new_ret_no_self</code> lint</a> which checks to ensure that, as a convention, <code>new</code> methods are used to make a new instance of a type and return that instance as the return value.
In the issue, the build is only failing on the <code>beta</code> release channel which was surprising because I was expecting this lint to have failed the build on the <code>stable</code> release channel as well if it failed on <code>beta</code>.
To further confuse the issue the build on <code>nightly</code>, which per our configuration for <code>supernova</code> is allowed to fail, was successful.</p>
<p>Digging into the problem some more, it looks like we are running into <a href="https://github.com/rust-lang-nursery/rust-clippy/issues/3313"><code>rust-lang-nursery/rust-clippy#3313</code></a> where the <code>new_ret_no_self</code> lint is incorrectly triggering on a <code>new</code> function that <em>does</em> return <code>Self</code>, it&rsquo;s just wrapped by a container type or tuple.</p>
<p>Indeed, we can see this from our implementation of <code>Config::new</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(<span style="color:#66d9ef">mut</span> args: <span style="color:#a6e22e">env</span>::Args) -&gt; Result<span style="color:#f92672">&lt;</span>Config, <span style="color:#f92672">&amp;</span>&#39;static <span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span> {
    args.next();

    <span style="color:#66d9ef">let</span> username <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> args.next() {
        None <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(<span style="color:#e6db74">&#34;No username provided&#34;</span>),
        Some(arg) <span style="color:#f92672">=&gt;</span> arg,
    };

    <span style="color:#66d9ef">let</span> token <span style="color:#f92672">=</span> args.next();

    Ok(Config { username, token })
}
</code></pre></div><p>which triggers the resulting lint failure</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">error: methods called `new` usually return `Self`
  --&gt; src/lib.rs:18:5
   |
18 | /     pub fn new(mut args: env::Args) -&gt; Result&lt;Config, &amp;&#39;static str&gt; {
19 | |         args.next();
20 | |
21 | |         let username = match args.next() {
...  |
28 | |         Ok(Config { username, token })
29 | |     }
   | |_____^
   |
   = note: `-D clippy::new-ret-no-self` implied by `-D warnings`
   = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/v0.0.212/index.html#new_ret_no_self
</code></pre></div><p>even though our return type is <code>Result&lt;Config, &amp;'static str&gt;</code> which unwraps to <code>Config</code> on success and a <code>static str</code> when there is an error in creating a new instance.</p>
<h2 id="investigating-the-root-cause">Investigating the Root Cause</h2>
<p>An important part of build infrastructure is reproducibility: the ability to run a build with the same inputs and get the same outputs.
Without reproducibility we have flaky tests that no one wants to run and worse, no one trusts.
In the case of <code>supernova</code> we have a build matrix to test on all three release channels: <code>stable</code>, <code>beta</code>, and <code>nightly</code>, and we need to make sure testing on these channels happens in a predictable way.</p>
<p>It turns out the issue results from how <code>clippy</code> is installed in each environment.
The recommended way to install <code>clippy</code> is as a <code>rustup</code> component using <code>rustup component add clippy-preview</code>.
However, because <code>clippy</code> is published as a component for <code>rustup</code> rather than as some kind of version-pinned project dependency, this command does not install the same version of <code>clippy</code> across all release channels.
This can be verified as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">$ cargo +stable clippy --version
clippy 0.0.212 (125907ad 2018-09-17)

$ cargo +beta clippy --version
clippy 0.0.212 (b1d03437 2018-10-19)

$ cargo +nightly clippy --version
clippy 0.0.212 (d8b42690 2018-11-04)
</code></pre></div><p>Note that while all of the build numbers are the same (<code>v0.0.212</code>), the commit hashes and dates are all different.</p>
<p>It is important to verify that the tool(s) you&rsquo;re using to test or lint your project are the same version in <strong>all</strong> of your environments, otherwise you&rsquo;ll end up with confusing build failures like the one we did here.
In our case we are testing against <code>beta</code> and <code>nightly</code> to have an idea of future changes to the Rust compiler and any new lints that may get added in the future, so failures on anything but <code>stable</code> are nice-to-have information rather than complete show-stoppers.
In other cases, or in different matrices, it&rsquo;s even more important that the test environment is as consistent as possible and that the number of variables that <em>are</em> being changed are as small as possible to make tracing failures relatively simple.</p>
<p>Lint tools are great for catching low-hanging fruit in code review, but you can&rsquo;t blindly trust them.
When there <em>is</em> a failure, it takes a person&rsquo;s knowledge of the project to determine if the failure is legitimate or if there&rsquo;s a problem in the tool or lint rule and to determine if it&rsquo;s a problem with the submitted code, a problem with the tool configuration, or a false positive in the tool as in this case with <code>clippy</code>&rsquo;s <code>new_ret_no_self</code> lint.</p>
<h2 id="fixing-the-problem">Fixing the Problem</h2>
<p>After <a href="https://github.com/0xazure/supernova/pull/24#issuecomment-437530272">reaching out to some friends</a> in the <code>#rust</code> IRC channel, we decided to <a href="https://github.com/0xazure/supernova/pull/27">not run <code>clippy</code> on the <code>beta</code> toolchain</a> to avoid more false positives like this in the future.
We are keeping <code>clippy</code> enabled for the <code>nightly</code> release channel because we are allowing <code>nightly</code> to fail on Travis so while we will investigate those failures it will not block landing any pull requests if for some reason <code>nightly</code> or <code>clippy</code> on <code>nightly</code> finds fault with our code.</p>
<p>I also recently filed <a href="https://github.com/0xazure/supernova/issues/32"><code>0xazure/supernova#32</code></a> to provide better visibility into the versions of tools we install to match how Travis prints out tooling versions for tools that come automatically installed with the Rust build environment.
This should help us track down version discrepancies and make trouble-shooting failures much quicker.</p>
<p>After landing the above fix (and <a href="https://github.com/0xazure/supernova/pull/30">an extra tweak</a> so we only run Travis against the <code>master</code> branch), our builds went fully green <a href="https://travis-ci.org/0xazure/supernova/builds/455179153">for the first time</a> since we enabled Travis on the project!
Setting up automated builds can take a lot of up-front effort, but it pays big dividends as the project grows to ensure the quality of the software being written.
Now we just <a href="https://github.com/0xazure/supernova/issues/8">need some tests</a> so we can verify our code is actually correct&hellip;</p>

                    </div>
                </section>
                
            </div>
            

            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="https://gohugo.io/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src='https://stuartcrust.com/js/all.min.js'></script>

        </div>
    </div>
</div>
</body>
</html>
